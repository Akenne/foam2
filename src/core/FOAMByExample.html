<html>
 <head>
  <script language="javascript" src="stdlib.js"></script>
  <script language="javascript" src="mm.js"></script>
  <script language="javascript" src="debug.js"></script>
  <title>FOAM By Example</title>
  <style>
    code {color:blue;}
  </style>
 </head>

 <body style="font-family:monospace;">

<script id='demo' language="xjavascript">
// Define a new class with foam.CLASS
foam.CLASS({
  name: 'Test',
  properties: [
    // short-form
    'a',
    // long-form
    {
      name: 'b'
    }
  ],
  methods: [
    // short-form
    function f1() { return 1; },
    // long-form
    {
      name: 'f2',
      code: function() { return 2; }
    }
  ]
});
log(Test);

// Use class.describe() to learn about the class
Test.describe();

// Create an instance of Test
var o = Test.create();
log(o);
log(o.a, o.b);

// Create an instance with a map argument to initialize properties
var o = Test.create({a:1, b:'foo'});
log(o.a, o.b);

// Objects have a reference to their class in .cls_
log(o.cls_.name);

// Test Class membership with Class.isInstance()
log(Test.isInstance(o), Test.isInstance('foo'));

// Call Methods
log(o.f1(), o.f2());

// Update Properties
o.a++;
o.b = 'bar';
log(o.a, o.b);

// Multiple properties can be updated at once using copyFrom().
o.copyFrom({a: 42, b: 'rosebud'});
log(o.a, o.b);

// Call toString on an object
log(o.toString());

// Call describe() on an object to see its Property values
o.describe();

// Properties and Methods are types of Axioms
// Get an array of all Axioms belonging to a Class by calling getAxioms.
Test.getAxioms().forEach(function(a) { console.log(a.cls_.name, a.name); });

// Find an Axiom for a class using getAxiomByName
log(Test.getAxiomByName('a'));

// Find all Axioms of a particular class using getAxiomsByClass
log(Test.getAxiomsByClass(foam.core.Method));

// Properties are defined on the class as constants
log(foam.core.Method.NAME);
foam.core.Method.NAME.describe();

// Property constants contain map functions
log(Test.getAxiomsByClass(foam.core.Method).map(foam.core.Method.NAME.f));

// Property constants contain comparators
log(Test.getAxiomsByClass(foam.core.Method).sort(foam.core.Method.NAME.compare).map(foam.core.Method.NAME.f));

// If a Class defineds an init() method, itss called
// when an object is created.
foam.CLASS({
  name: 'InitTest',
  methods: [ function init() { log('Just Born!'); } ]
});
InitTest.create();

// Default Values can be defined for Properties
foam.CLASS({
  name: 'DefaultValueTest',
  properties: [
    { name: 'a', defaultValue: 42 },
    { name: 'b', defaultValue: 'foo' },
    { name: 'c' }
  ]
});
var o = DefaultValueTest.create();
log(o.a, o.b, o.c);

// .hasOwnProperty() tells you if a Property has been set
log(o.hasOwnProperty('a'), o.hasOwnProperty('b'), o.hasOwnProperty('c'));
o.a = 99;
o.b = 'bar';
o.c = 'test';
log(o.hasOwnProperty('a'), o.hasOwnProperty('b'), o.hasOwnProperty('c'));

// .clearProperty() reverts a value back to its defaultValue
log(o.hasOwnProperty('a'), o.a);
o.clearProperty('a');
log(o.hasOwnProperty('a'), o.a);

// factories
// Properties can have factory methods which create their initial value
// when they are first accessed.
foam.CLASS({
  name: 'FactoryTest',
  properties: [
    {
      name: 'a',
      factory: function() { log('creating value'); return 42; }
    }
  ]
});
var o = FactoryTest.create();
log(o.a);
// Factory not called value accessed second time:
log(o.a);

// Factory not called if value supplied in constructor
var o = FactoryTest.create({a: 42});
log(o.a);

// Factory not called if value set before first access
var o = FactoryTest.create();
o.a = 42;
log(o.a);

// Factory called again if clearProperty() called:
var o = FactoryTest.create();
log(o.a);
o.clearProperty('a');
log(o.a);

// getters and setters
// Properties can define their own getter and setter functions.
foam.CLASS({
  name: 'GetterSetter',
  properties: [
    'radius',
    {
      name: 'diameter',
      getter: function() { return this.radius * 2; },
      setter: function(diameter) { this.radius = diameter / 2; }
    }
  ]
});
var o = GetterSetter.create();
o.diameter = 10;
log(o.radius, o.diameter);
o.radius = 10;
log(o.radius, o.diameter);

// Properties can specify an 'adapt' function which is called whenever
// the properties' value is updated. It's the adapt function's responsibility
// to convert or coerce the type if necessary.
// Both the previous value of the property and the proposed new value are
// passed to adapt.  Adapt returns the desired new value, which may be different
// from the newValue it's provided.
foam.CLASS({
  name: 'AdaptTest',
  properties: [
    {
      name: 'flag',
      adapt: function(oldValue, newValue) {
        log('adapt ', oldValue, newValue);
        // adapt to a boolean
        return !! newValue;
      }
    }
  ]
});
var o = AdaptTest.create({flag:true});
o.flag = null;
log(o.flag);

// Properties can specify a 'preSet' function which is called whenever
// the properties' value is updated, just after 'adpat', if present.
// Both the previous value of the property and the proposed new value are
// passed to preSet.  PreSet returns the desired new value, which may be different
// from the newValue it's provided.
foam.CLASS({
  name: 'PreSetTest',
  properties: [
    {
      name: 'a',
      preSet: function(oldValue, newValue) {
        log('preSet p1');
        return 'Mr. ' + newValue;
      }
    }
  ]
});
var o = PreSetTest.create({a: 'Smith'});
o.a = 'Jones';
log(o.a);

// Properties can specify a 'postSet' function which is called after
// the properties' value is updated.  PostSet has no return value.
foam.CLASS({
  name: 'PostSetTest',
  properties: [
    {
      name: 'a',
      postSet: function(oldValue, newValue) {
        log('postSet', oldValue, newValue);
      }
    }
  ]
});
var o = PostSetTest.create({a: 'Smith'});
o.a = 'Jones';
o.a = 'Green';

// Properties can define 'adapt', 'preSet', and 'postSet' all at once.
foam.CLASS({
  name: 'AdaptPrePostTest',
  properties: [
    {
      name: 'a',
      adapt: function(oldValue, newValue) {
        log('adapt: ', oldValue, newValue);
        return newValue + 1;
      },
      preSet: function(oldValue, newValue) {
        log('preSet: ', oldValue, newValue);
        return newValue + 1;
      },
      postSet: function(oldValue, newValue) {
        log('postSet: ', oldValue, newValue);
      }
    }
  ]
});
var o = AdaptPrePostTest.create();
o.a = 1;
o.a = 10;

// Classes can also define Constnts.
foam.CLASS({
  name: 'ConstantTest',
  constants: {
    MEANING_OF_LIFE: 42,
    FAVOURITE_COLOR: 'green'
  }
});
var o = ConstantTest.create();
log(o.MEANING_OF_LIFE, o.FAVOURITE_COLOR);

// Constants can also be accessed from the Class
log(ConstantTest.MEANING_OF_LIFE, ConstantTest.FAVOURITE_COLOR);
log(o.cls_.MEANING_OF_LIFE, o.cls_.FAVOURITE_COLOR);

// Constants are constant
o.MEANING_OF_LIFE = 43;
log(o.MEANING_OF_LIFE);

// Classes can be subclassed with 'extends:'.
// Methods in subclasses can override methods from ancestor classes, as is
// done below with toString().  Employee.toString() calls its parent classes
// toString() method by calling 'this.SUPER()'.
foam.CLASS({
  name: 'Person',
  properties: [ 'name', 'sex' ],
  methods: [
    function toString() { return this.name + ' ' + this.sex; }
  ]
});
foam.CLASS({
  name: 'Employee',
  extends: 'Person',
  properties: [ 'salary' ],
  methods: [
    function toString() { return this.SUPER() + ' ' + this.salary; }
  ]
});
var p = Person.create({name: 'John', sex: 'M'});
log(p.toString());
var e = Employee.create({name: 'Jane', sex: 'F', salary: 50000});
log(e.toString());

// Test if one class is a sub-class of another:
log(Person.isSubClass(Employee), Employee.isSubClass(Person));

// A Class is considered a sub-class of itself:
log(Person.isSubClass(Person));

// FObject is the root class of all other classes:
log(foam.core.FObject.isSubClass(Employee), foam.core.FObject.isSubClass(Person));

// In addition to being extended, a Class can also be refined.
// Refinement upgrades the existing class rather than create a
// new sub-class. In the following example we add 'salary' to
// the person class, rather than creating a new Employee sub-class.
foam.CLASS({
  name: 'Person',
  properties: [ 'name', 'sex' ],
  methods: [
    function toString() { return this.name + ' ' + this.sex; }
  ]
});
var oldPerson = Person.create({name: 'John', sex: 'M'});
foam.CLASS({
  refines: 'Person',
  properties: [ { name: 'salary', defaultValue: 0 } ],
  methods: [
    function toString() { return this.SUPER() + ' ' + this.salary; }
  ]
});
Person.describe();
var e = Person.create({name: 'Jane', sex: 'F', salary: 50000});
log(e.toString());
log(oldPerson.toString());

// TODO: BooleanProperty

// TODO: IntProperty

// TODO: StringProperty

// TODO: ArrayProperty

// Listeners are pre-bound Methods, suitable for use as callbacks (DOM, or otherwise).
foam.CLASS({
  name: 'ListenerTest',
  properties: [ 'name' ],
  methods: [ function m1() { console.log('m1', this.name); } ],
  listeners: [ function l1() { console.log('l1', this.name); } ]
});
var o = ListenerTest.create({name: 'Steve'});
// When called as methods, the same as Methods.
log(o.m1(), o.l1());

// But when called as functions, the method forgets its 'self' and doesn't work,
// but the listener does.
var m = o.m1, l = o.l1;
log(m(), l());

// TODO: isMerged

// TODO: mergeDelay

// TODO: isFramed

// TODO: ability to augment an existing Class(es), foam.ENHANCE()

// In addition to class-inheritance, FOAM also supports
// 'Traits', which are a form of multiple-inheritance which
// copy Axioms from another model.
foam.CLASS({
  name: 'SampleTrait',
  properties: [ 't1', 't2', 't3' ],
  methods: [
    function tfoo() { console.log('ffoo'); },
    function tbar() { console.log('tbar'); }
  ]
});
foam.CLASS({
  name: 'TraitTest',
  traits: ['SampleTrait'],
  properties: [ 'p1', 'p2', 'p3' ],
  methods: [
    function foo() { console.log('foo'); },
    function bar() { console.log('bar'); }
  ]
});
TraitTest.describe();
var tt = TraitTest.create({p1:1, t1:2});
tt.describe();
tt.tfoo(); // From SampleTrait
tt.foo();

// Unlike regular inheritance with extends:, classes
// can inherit from multiple traits.
foam.CLASS({
  name: 'SampleTrait2',
  properties: [ 'tb1', 'tb2', 'tb3' ],
  methods: [
    function tbfoo() { console.log('ffoo'); },
    function tbbar() { console.log('tbar'); }
  ]
});
foam.CLASS({
  name: 'TraitTest2',
  traits: ['SampleTrait', 'SampleTrait2']
});
TraitTest2.describe();

// Classes can have inner-Classes.
foam.CLASS({
  name: 'InnerClassTest',
  classes: [
    { name: 'InnerClass1', properties: ['a', 'b'] },
    { name: 'InnerClass2', properties: ['x', 'y'] }
  ],
  methods: [
    function init() {
      var ic1 = this.InnerClass1.create({a:1, b:2});
      var ic2 = this.InnerClass2.create({x:5, y:10});
      log(ic1.a, ic1.b, ic2.x, ic2.y);
    }
  ]
});
InnerClassTest.create();

// Inner-classes can also be accessed from the outer-class
InnerClassTest.InnerClass1.describe();

// Inner-classes do not appear in the global namespace
// TODO: isn't true yet
log(! InnerClass1);

// Objects support publish() for publishing events,
// and subscribe() for listening for published events.
foam.CLASS({
  name: 'PubSubTest'
});
var o = PubSubTest.create();
// Install a listener that listens to all events
o.subscribe(function() { console.log('global listener: ', [].join.call(arguments, ' ')); });
o.subscribe('alarm', function() { console.log('alarm: ', [].join.call(arguments, ' ')); });
o.publish('alarm', 'on');
o.publish('lifecycle', 'loaded');

// A Class can declare 'Topics' that it publishes events for.
foam.CLASS({
  name: 'TopicTest',
  topics: [ 'alarm' ]
});
var o = TopicTest.create();
o.subscribe('alarm', function(_, _, state) { console.log('alarm: ', state); });
// The next line uses the Topic and is slightly shorter than the equivalent above.
o.alarm.subscribe(function(_, _, state) { console.log('alarm (topic): ', state); });
o.alarm.publish('on');
o.publish('alarm', 'off');

// Objects implicitly publish events on the 'propertyChange' topic when
foam.CLASS({
  name: 'PropertyChangeTest',
  properties: [ 'a', 'b' ]
});
o = PropertyChangeTest.create();
// Listen for all propertyChange events:
o.propertyChange.subscribe(function(sub, p, name, dyn) { console.log('propertyChange: ', p, name, dyn.getPrev(), dyn.get()); });
// Listen for only changes to the 'a' Property:
o.propertyChange.subscribe('a', function(sub, p, name, dyn) { console.log('propertyChange.a: ', p, name, dyn.getPrev(), dyn.get()); });
o.a = 42;
o.b = 'bar';
o.a++;

// There are four ways to unsubscribe a listener
// 1. Call obj.unsubscribe();
o = TopicTest.create();
var l = function() { console.log.apply(console.log, arguments); };
o.subscribe(l);
o.publish('fire');
o.unsubscribe(l);
o.publish("fire again, but nobody's listenering");

// 2. Call .destroy() on the Destroyable that subscribe() returns
var sub = o.subscribe(l);
o.publish('fire');
sub.destroy();
o.publish("fire again, but nobody's listenering");

// 3. Destroy the subscription, which is supplied to the listener
var l = function(sub) {
  sub.destroy();
  console.log.apply(console.log, arguments);
};
o.subscribe(l);
o.publish('fire');
o.publish("fire again, but nobody's listenering");

// 4. If you only want to receive the first event, decorate your
// listener with foam.events.oneTime() and it will cancel the subscription
// when it receives the first event.
o.subscribe(foam.events.oneTime(function() { console.log.apply(console.log, arguments); }));
o.publish('fire');
o.publish("fire again, but nobody's listenering");

// DynamicValues are like Object-Oriented pointers.
// A properties dynamic-value is accessed as 'name'$.
// get() is used to dereference the value of a dynamic
var p = Person.create({name: 'Bob'});
var dyn = p.name$;
log(dyn.get());

// set() is used to set a dynamic's value:
dyn.set('John');
log(p.name, dyn.get());

// Calling obj.propertyDynamcic('name') is the same as obj.name$.
var p = Person.create({name: 'Bob'});
var dyn = p.propertyDynamic('name');
log(dyn.get());
dyn.set('John');
log(dyn.get());

// Two-Way Data-Binding
// Dynamic values can be assigned, causing two values to be
// bound to the same value.
var p1 = Person.create(), p2 = Person.create();
p1.name$ = p2.name$;
p1.name = 'John';
log(p1.name, p2.name);
p2.name = 'Steve';
log(p1.name, p2.name);

// Another way to link to Dynamics is to call .link() on one of them.
var p1 = Person.create(), p2 = Person.create();
var d = p1.name$.link(p2.name$);
p1.name = 'John';
log(p1.name, p2.name);

// But this style of link can be broken by calling .destroy()
// on the object return from .link().
d.destroy();
p2.name = 'Steve';
log(p1.name, p2.name);

// One-Way Data-Binding
// Calling .link() creates a two-way data-binding, meaning a change in either
// value is reflected in the other.  But FOAM supports one-way data-binding as well.
// To do this, use the .follow() method.
var d = p1.name$.follow(p2.name$);
p2.name = 'Ringo'; // Will update p1 and p2
log(p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log(p1.name, p2.name);

// Dynamic Values also let you check if the value is defined by calling isDefined().
// Calling obj.name$.isDefined() is equivalent to obj.hasOwnProperty('name');
foam.CLASS({name: 'IsDefinedTest', properties: [ { name: 'a', defaultValue: 42 } ]});
var o = IsDefinedTest.create();
var dv = o.a$;
log(dv.isDefined());
dv.set(99);
log(dv.isDefined());

// You can reset a Dynamic Value to its default value by calling .clear().
// Calling obj.name$.clear() is equivalent to obj.clearProperty('name');
dv.clear();
log(dv.get(), dv.isDefined());

// Contexts can be explicitly created with foam.sub()
// The second argument of sub() is an optional name for the Context
var Y1 = foam.sub({key: 'value', fn: function() { console.log('here'); }}, 'SubContext');
console.log(Y1.key, Y1.fn());

// Sub-Contexts can be created from other Contexts.
var Y2 = Y1.sub({key: 'value2'});
console.log(Y2.key, Y2.fn());

// A Context's contents can be inspected with .describe();
Y1.describe();
Y2.describe();

// Packages
// Classes can specify a 'package'.
foam.CLASS({
  package: 'com.acme',
  name: 'Test',
  methods: [ function foo() { console.log('foo from com.acme.Test'); } ]
});
com.acme.Test.create().foo();

// Classes can requires: other Classes to avoid having to reference them
// by their fully-qualified names.
foam.CLASS({
  name: 'RequiresTest',
  requires: [ 'com.acme.Test' ],
  methods: [ function foo() { this.Test.create().foo(); } ]
});
RequiresTest.create().foo();

// A Classes 'id' is a combination of its package and name.
log(com.acme.Test.id);

// Stdlib

// All Objects have a unique identifier, accessible with the .$UID property.
var a = {}, b = [], c = Person.create();
log(a.$UID, b.$UID, c.$UID);
log(a.$UID, b.$UID, c.$UID);

// foam.array.argsToArray() is a convenience method for converting the psedo-array 'arguments'.
(function() {
  log(Array.isArray(arguments), Array.isArray(foam.array.argsToArray(arguments)));
})();

// foam.events.consoleLog
foam.CLASS({name: 'ConsoleLogTest'});
var o = ConsoleLogTest.create();
o.subscribe(foam.events.consoleLog());
o.publish();
o.publish('foo');
o.publish('foo','bar');

// foam.fn.memoize1() memozies a one-argument function so that if called again
// with the same argument, the previously generated value will be returned
// rather than calling the function again.
var f = foam.fn.memoize1(function(x) { log('calculating ', x); return x*x; });
log(f(2));
log(f(2));
log(f(4));

// A call to memoize1() with no arguments will trigger a failed assertion.
log(f());

// A call to memoize1() with more than one argument will trigger a failed assertion.
log(f(1,2));

// foam.string.constantize converts strings from camelCase to CONSTANT_FORMAT
log(foam.string.constantize('foo'));
log(foam.string.constantize('fooBar'));
log(foam.string.constantize('fooBar12'));

// foam.string.pad() pads a string to the specified length.
var s = foam.string.pad('foobar', 10);
log(s, s.length);

// foam.string.pad() pads a string to the specified length, right justifying if given a negative number.
var s = foam.string.pad('foobar', -10);
log(s, s.length);

</script>

  <div id='output'></div>

  <script language="javascript">
    var demo = document.getElementById('demo');
    var out  = document.getElementById('output');
    var log_ = function(o) {
      if ( o.indexOf('<') != 0 ) o = o.replace(/\n/g, '<br>').replace(/ /g,'&nbsp;');
//      out.innerHTML = out.innerHTML + o + '<br/>';
      document.body.insertAdjacentHTML('beforeend', o + '<br/>');
    }
    var oldLog = console.log;
    console.assert = function(b, e) { if ( ! b ) { log('Assertian failed:', e); throw 'assert'; } };
    console.log = function() { log_([].join.call(arguments, ' ')); };
    console.log.put = console.log.bind(console);
    console.log.str = oldLog.str;
    console.log.json = oldLog.json;
    var log = function() { log_(' <b>&gt;</b> ' + [].join.call(arguments, ' ')); }

    var s_ = demo.textContent.split('\n\n');
    for ( var i_ = 0 ; i_ < s_.length ; i_++ ) {
      var line = s_[i_];
      log_(' <h3>Example ' + (i_+1) + '</h3><code>' + line + '</code><br>');
      try {
        eval(line);
      } catch (x) {
        log('Exception: ', x);
      }
      log_('');
    }
  </script>

 </body>
</html>
